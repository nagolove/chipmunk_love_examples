-- vim: set colorcolumn=85
-- vim: fdm=marker

--[[
--local debug_print = print
local dprint = require 'debug_print'
local debug_print = dprint.debug_print

local colorize = require 'ansicolors2'.ansicolors
debug_print('thread', colorize('%{yellow}>>>>>%{reset} t80 started'))

require "love_inc".require_pls_nographic()

debug_print('thread', 'love.filesystem.getRequirePath()', love.filesystem.getRequirePath())

--local require_path = SCENE_PREFIX .. "/?.lua;?.lua;?/init.lua;"
local require_path = "scenes/t80/?.lua;?.lua;?/init.lua;"
print('require_path', require_path)
love.filesystem.setRequirePath(require_path)

print('getCRequirePath()', love.filesystem.getCRequirePath())

love.filesystem.setCRequirePath("scenes/t80/?.so;?.so")

print("package.cpath", package.cpath)

print('getWorkingDirectory', love.filesystem.getWorkingDirectory())

local wrp = require "wrp"
local Wrapper = wrp
--print('wrp', inspect(wrp))

require "love"
require 'konstants'
require 'joystate'
require 'pipeline'
require "common"

-- Доработка keyconfig для джойстика
require "keyconfig"

--local tween = require 'tween'
--local camMoveTween = tween.new()

local sformat = string.format
local inspect = require "inspect"
--local serpent = require 'serpent'
--local i18n = require "i18n"
local metrics = require "metrics"
local vec2 = require "vector"
--local vecl = require "vector-light"

-- Вывод в строку
--local tabular = require "tabular".show

local Pipeline = require 'pipeline'
local pipeline = Pipeline.new(SCENE_PREFIX)

local docsystem = require 'doc-system'

-- рисование стрелочек векторов
local arrow = require 'arrow'
arrow.init(pipeline)

--local Shortcut = KeyConfig.Shortcut

--local abs, pow, sqrt = math.abs, math.pow, math.sqrt
--local abs = math.abs
local yield, resume = coroutine.yield, coroutine.resume

local enum State 
    'garage'
    'map'
end

local state: State = 'map'

-- }}}

-- Чем занят класс Arena?
-- Класс Arena применяется для хранения геометрии ограничивающей игровое поле.
-- Также объект класса позволяет записать полное описание сцены в строку или файл и
-- восстановить сцену из файла. Сцена содержит списки танков, списки ребер, списки ангаров.
local record Arena
    -- {{{
    new: function(fname: string): Arena
    -- }}}
end

--Ангар - место порождения техники и ее ремонта.
local record Hangar
    vertices: {number}
    id: integer
    --objectType: ObjectType
    color: {number}
    --physbody: Physics.Body
    --polyshape: lp.PolygonShape
    rectXY: {number}
    rectWH: {number}
    --fixture: Physics.Fixture

    new: function(): Hangar
    update: function(Hangar)
    present: function(Hangar)
end

local Tank = require 'tank'

--local type ParticlesMap = {string: ParticleSystemDefinition}

-- То, что создается когда происходит попадание снаряда в танк.
local record Hit 
    -- {{{
    -- в пикселях
    x: number
    -- в пикселях
    y: number
    ps: love.graphics.ParticleSystem

    -- координаты в метрах
    new: function(x: number, y: number): Hit
    -- }}}
end

-- {{{ Global and local variables.

local screenW, screenH: number, number

local space: Wrapper.Space
local space_damping = 0.02

-- {{{ Konsole editing
--local historyfname = "cmdhistory.txt"

require "Timer"

local physics_pause = false

-- Все танки, в том числе и тот, которым управляет игрок.
local tanks: {Tank} = {}

-- Ангары(точки для ремонта, также точки появления техники
local hangars: {Hangar} = {}

-- Танк, которым управляет игрок
local playerTank: Tank

-- Логотип, картинка или главное меню?
require 'logo'

local record Borders
    x1: number
    y1: number
    x2: number
    y2: number
end

local rng: love.math.RandomGenerator = love.math.newRandomGenerator()

rng:setSeed(300 * 123414)
--rng:setSeed(os.time())

local DiamonAndSquare = require 'diamondsquare'
--local diamondSquare: DiamonAndSquare = DiamonAndSquare.new(8, rng, pipeline)
local diamondSquare: DiamonAndSquare = DiamonAndSquare.new(5, rng, pipeline)
--local diamondSquare: DiamonAndSquare = nil

--local loadCannonSound = Audio.newSource(SCENE_PREFIX .. "/load.wav", 'static')
--local audMainTheme = Audio.newSource(SCENE_PREFIX .. "/audio/Lime of Adventure.mp3", 'static')

local event_channel = love.thread.getChannel("event_channel")
local main_channel = love.thread.getChannel("main_channel")

local is_stop = false
local last_render: number = love.timer.getTime()

local PCamera = require "pcamera"
local camera: PCamera

-- Границы в которых создаются танки
-- Сделать сохраняемыми и загружаемыми из файла.
local bordersArea: Borders = {}
--local borders: {Borders} = {}

local segments: {wrp.Shape} = {}

local lj = love.joystick
local Joystick = lj.Joystick
local joyState: JoyState
local joy: Joystick

local function initJoy()
    for _, j in ipairs(lj.getJoysticks()) do
        debug_print("joy", colorize('%{green}' .. inspect(j)))
    end
    joy = lj.getJoysticks()[1]
    if joy then
        debug_print("joy", colorize('%{green}avaible ' .. joy:getButtonCount() .. ' buttons'))
        debug_print("joy", colorize('%{green}hats num: ' .. joy:getHatCount()))
    end
    joyState = JoyState.new(joy)
end

local function print_fps()
    local msg = sformat("fps %d", love.timer.getFPS())
    pipeline:push('add', 'fps', msg)
end

local function print_io_rate()
    local bytes = pipeline:get_received_in_sec()
    local msg = sformat("передано за секунду Килобайт = %d", math.floor(bytes / 1024))
    pipeline:push('add', 'data_received', msg)
end

function Hangar.new(_: vector): Hangar
    local Hangar_mt: metatable<Hangar> = {
        __index = Hangar,
    }
    local self = setmetatable({} as Hangar, Hangar_mt)
    --self.objectType = "Hangar"
    return self
end

function Hangar:update()

end

function Hangar:present()
end

function Hit.new(x: number, y: number): Hit
    local Hit_mt: metatable<Hit> = {
        __index = Hit,
    }
    local self: Hit = setmetatable({} as Hit, Hit_mt)

    self.ps = nil
    error('self.ps = nil')

    --x, y = x * M2PIX, y * M2PIX

    self.x = x
    self.y = y

    return self
end

function Arena.new(_: string): Arena
    local Arena_mt: metatable<Arena> = { __index = Arena }
    local self: Arena = setmetatable({} as Arena, Arena_mt)

    --self.objectType = "Arena"

    return self
end

--local base_tex_fname = 'tank_body_small.png'
local base_tex_fname = 'tank_body.cut.png'
local turret_text_fname = 'tank_tower.png'

local function getTankSize(): integer, integer
    local path = SCENE_PREFIX .. '/' .. base_tex_fname
    local image = love.image.newImageData(path)
    if not image then
        error('Could not load base_tex_fname: ' .. path)
    end
    return image:getDimensions() as (integer, integer)
end

local tank_width, tank_height = getTankSize()

-- возвращает массив со значениями координат углов ландшафта в метрах по часовой
-- стрелке от левого верхнего угла.
function getTerrainCorners(): {vector}
end

--local currentParticesType: integer = 0

global str: string = ""

local function on_each_body_t(
    x: number, y: number, angle: number, obj: any,
    tur_x: number, tur_y: number, tur_angle: number,
    debug_vertices: {{number}}
)
    local tank = obj as Tank

    if type(tank) ~= "table" then
        error("tank should be a table, not a " .. type(tank))
    end

    if tank then
        pipeline:push('new_t', tank.id, x, y, angle, tur_x, tur_y, tur_angle)
    end
end

local function renderSegments()
    pipeline:open('border_segments')
    wrp.static_segments_draw(
        function(x1: number, y1: number, x2: number, y2:number)
            pipeline:push('draw', x1, y1, x2, y2)
        end
    )
    pipeline:push('flush')
    pipeline:close()
end

local function debug_draw_vertices(
    x: number, y: number, angle: number, obj: any,
    tur_x: number, tur_y: number, tur_angle: number,
    debug_vertices: {{number}}
)
    if debug_vertices then
        pipeline:push("new")

        print(colorize("%{yellow}debug_draw_vertices"))

        --pipeline:push("new", 2, 'enough')

        --pipeline:push(2)
        --pipeline:push({ 1, 2, 4, 5, 100, 100})
        --pipeline:push({ 10, 20, 40, 50, 10, 10})

        pipeline:push(#debug_vertices)
        for i = 1, #debug_vertices do
            pipeline:push(debug_vertices[i])
        end
    else
        --print("no debug vertices.")
    end
end

local function renderTanks()

    pipeline:open('base_shape')
    --wrp.query_all_tanks(on_each_body)
    wrp.query_all_tanks_t(on_each_body_t)
    pipeline:push('flush')
    pipeline:close()

    --wrp.query_all_tanks(on_each_body)
    pipeline:open("debug_vertices")
    wrp.query_all_tanks_t(debug_draw_vertices)
    pipeline:push('enough')
    pipeline:close()
end

local function renderSelectedObject(): number, number
    local player_x, player_y: number, number
    if playerTank then
        pipeline:open('selected_object')
        local body = playerTank.base
        player_x, player_y = body:get_position()

        --print('selected_object: ', player_x, player_y)
        --print_body_stat(body)
        --print('----------------------------------------------')

        --pipeline:push(wrp.get_position(body))
        pipeline:push(body:get_position())
        pipeline:close()
    else
        error('Player should not be nil')
    end
    return player_x, player_y
end

local function renderLinesBuf(player_x: number, player_y: number)
    pipeline:open('lines_buf')
    print_io_rate()
    print_fps()
    camera:push2lines_buf()
    local msg = sformat("player pos (%.3f, %.3f)", player_x, player_y)
    pipeline:push("add", "player_pos", msg)

    -- Верно-ли, что здесь единственный вызов flush() для данного объекта в
    -- кадре?
    pipeline:push('flush')

    pipeline:close()
end

local is_draw_hotkeys_docs = false
local is_draw_gamepad_docs = false

local function renderInternal()
    pipeline:openAndClose('clear')

    -- Установка камеры
    camera:setTransform()

    -- Ландшафт
    diamondSquare:render()

    -- Танки
    renderTanks()
    -- Ограничители уровня, преграды в виде отрезков.
    renderSegments()

    -- Выделенный объект - управляемый игроком
    local player_x, player_y = renderSelectedObject()

    -- Оси на экране из (0, 0)
    pipeline:openAndClose('main_axises')

    -- Инфа об объекте под мышкой
    pipeline:openPushAndClose('object_lines_buf', 'flush')

    -- Сброс трансформации камеры
    camera:setOrigin()

    -- Строчки с отладочной инфой.
    renderLinesBuf(player_x, player_y)

    -- Оси через центр экрана
    camera:draw_axises()

    if is_draw_hotkeys_docs then
        docsystem.draw_keyboard()
    end
    if is_draw_gamepad_docs then
        docsystem.draw_gamepad()
    end
end

local function renderScene()
    local nt = love.timer.getTime()
    -- Ограничение кадров в секунду до 300
    local fps_limit = 1. / 300.
    local diff = nt - last_render

    if diff >= fps_limit then
        last_render = nt
        renderInternal()
        pipeline:sync()
    end
end

local function updateTanks()
    -- {{{
    local alive: {Tank} = {}
    for _, tank in ipairs(tanks) do
        local t =  tank:update()
        if t then
            table.insert(alive, t)
        else
            print('---------------')
        end
    end
    tanks = alive
    -- }}}
end

--[[
local function backspaceCmdLine()
    -- {{{
    local u8 = require "utf8"
    -- get the byte offset to the last UTF-8 character in the string.
    local byteoffset = u8.offset(cmdline, -1)
    if byteoffset then
        -- remove the last UTF-8 character.
        -- string.sub operates on bytes rather than UTF-8 characters, 
        -- so we couldn't do string.sub(text, 1, -2).
        cmdline = string.sub(cmdline, 1, byteoffset - 1)
        if cursorpos - 1 >= 1 then
            cursorpos = cursorpos - 1
        end
    end
    -- }}}
end
--]]

--local function enterCommandMode()
--end

--[[
local function leaveCommandMode()
    -- {{{
    print("command mode disabled.")
    mode = "normal"
    love.keyboard.setKeyRepeat(false)
    love.keyboard.setTextInput(false)
    cmdline = ""
    -- }}}
end
--]]

--[[
function attach(varname: string)
    if type(varname) == "string" then
        attachedVarsList[varname] = function()
            local ok, errmsg: boolean, string = pcall(function()
                local l = (_G as {any:any})[varname]
                local output = tabular.show2(l)
                if output then 

                else

                end
            end)
            if not ok then
                print("attach callback error:", errmsg)
                print('attach removed')
                attachedVarsList[varname] = nil
            end
        end
    end
end
--]]

--[[
function detach(varname: string)
    if type(varname) == "string" then
        attachedVarsList[varname] = nil
    end
end
--]]

--[[
local function evalCommand()
    -- {{{

    -- {{{ preload
    local path = SCENE_PREFIX .. '/eval_preload.lua'
    local content = love.filesystem.read(path)
    if not content then
        error('Could not load: ' .. path)
    end

    local preload = content
    -- }}}

    cmdline = trim(cmdline)
    local func, loaderrmsg: function, string = load(preload .. cmdline)
    --local time = 2

    --TODO в обработке ошибок искать ]:1: и обрезать сообщение об ошибке.
    if not func then
        --linesbuf:push(time, "load() errmsg: " .. loaderrmsg)
        print("load() errmsg:|" .. loaderrmsg .. "|")
    else
        local ok, pcallerrmsg: boolean, string = pcall(function()
            func()
        end)
        if not ok then
            --linesbuf:push(time, "pcall() errmsg: " .. pcallerrmsg)
            print("pcall() errmsg:|" .. pcallerrmsg .. "|")
        end
    end
    --local trimmed = trim(cmdline) or ""
    if #cmdline ~= 0 then
        table.insert(cmdhistory, cmdline)
        love.filesystem.append(historyfname, cmdline .. "\n")
    end
    --suggestList = nil
    -- }}}
end
--]]

--local cmdhistoryIndex = 0

--[[
local function setPreviousCommand()
    -- {{{
    if #cmdhistory ~= 0 then
        if cmdhistoryIndex - 1 < 1 then
            cmdhistoryIndex = #cmdhistory
        else
            cmdhistoryIndex = cmdhistoryIndex - 1
        end
        cmdline = cmdhistory[cmdhistoryIndex]
        cursorpos = #cmdline + 1
    end
    -- }}}
end
--]]

--[[
local function setNextCommand()
    -- {{{
    if #cmdhistory ~= 0 then
        if cmdhistoryIndex + 1 > #cmdhistory then
            cmdhistoryIndex = 1
        else
            cmdhistoryIndex = cmdhistoryIndex + 1
        end
        cmdline = cmdhistory[cmdhistoryIndex]
        cursorpos = #cmdline + 1
    end
    -- }}}
end
--]]

--[[
local function processCommandModeKeys(key: string)
    -- {{{
    if key == "backspace" then
        backspaceCmdLine()
    elseif key == "tab" then
        print('tab pressed.')
        suggestCompletion()
    elseif key == "escape" then
        leaveCommandMode()
    elseif key == "return" then
        evalCommand()
    elseif key == "up" then
        setPreviousCommand()
    elseif key == "down" then
        setNextCommand()
    elseif key == "left" then
        if cursorpos - 1 >= 1 then
            cursorpos = cursorpos - 1
        end
        print('left')
    elseif key == "right" then
        if cursorpos <= #cmdline then
            cursorpos = cursorpos + 1
        end
        print('right')
    elseif key == "home" then
        cursorpos = 1
        print('home')
    elseif key == "end" then
        cursorpos = #cmdline
        print('end')
    end
    -- }}}
end
--]]

--[[
-- Не добавляет в таблицу рисовки на стороне потока рендера.
-- Необходимо проверять - есть ли другой танк под текущей точкой. Принимать во
-- внимание ширину, высоту объекта и некоторый запас, 5-10 пикселей.
local function spawnTank(px: number, py: number): Tank
    local tank = Tank.new(vec2(px, py), tank_width, tank_height)
    print("tank", inspect(tank))
    table.insert(tanks, tank)
    local tank_x, tank_y, angle = tank.base:get_position()
    local turret_x, turret_y, turret_angle = tank.base:get_turret_position()

    --print(colorize(
        --"%{magenta}" .. 'body type: ' .. wrp.get_body_type(tank.base)
    --))

    print(colorize("%{yellow}spawnTank:%{reset}"),
        "\n     tank.id", tank.id, 
        "\n     tank_x", tank_x, 
        "\n     tank_y", tank_y, 
        "\n     angle", angle, 
        "\n     turret_x", turret_x, 
        "\n     turret_y", turret_y, 
        "\n     turret_angle", turret_angle
    )

    -- Эти значения используются в C модуле для определения на сколько
    -- сдвинулся объект с момента предыдущей обработки.
    tank._prev_x, tank._prev_y = tank_x, tank_y
    pipeline:openPushAndClose(
        'base_shape',
        'new_t', 
        tank.id, 
        tank_x, tank_y, angle, 
        turret_x, turret_y, turret_angle,
        "flush"
    )

    return tank
end

local function spawnTanks()

    local tanks_num = 2
    --local tanks_num = 100

    local minx, maxx = 0, 4000
    local miny, maxy = 0, 4000

    bordersArea.x1, bordersArea.y1 = minx, miny
    bordersArea.x2, bordersArea.y2 = maxx, maxy

    -- информация о танчиках записывается в таблицу на стороне потока рисования
    -- что-бы позже передавать данные только от изменивших положение объектах
    --pipeline:open('base_shape')

    local rad = 1000
    for _ = 1, tanks_num do
        --local px, py = rng:random(minx, maxx), rng:random(miny, maxy)
        local p = vec2.fromPolar(
            rng:random() * 2 * math.pi, 
            rad
        )
        --spawnTank(p.x, p.y)
    end

    --spawnTank(-100, 100)
    local w, h = 256, 256
    spawnTank(-w / 70, - h / 70)

    spawnTank(380, 100)
    spawnTank(screenW / 2, screenH / 2)
    --pipeline:push('enough')
    --pipeline:close()
end

-- Нарисовать параметр размера карты в буфер отладочных строк.
local function lines_buf_push_mapn()
    if not diamondSquare then
        return
    end
    pipeline:open('lines_buf')
    pipeline:push("add", 'mapn', "mapn: " .. diamondSquare.mapn)
    --pipeline:push('enough')
    pipeline:push('flush')
    pipeline:close()
end

-- Клавиши для управления генератором ландшафта.
local function processLandscapeKeys(key: string)
    if not diamondSquare then
        return
    end

    if key == 'r' then
        diamondSquare:reset()
        diamondSquare:eval()
        diamondSquare:send2render()
    end

    if key == 'z' then
        local mapn = diamondSquare.mapn - 1
        if mapn >= 1 then
            diamondSquare = DiamonAndSquare.new(mapn, rng, pipeline)
            diamondSquare:eval()
            diamondSquare:send2render()
            lines_buf_push_mapn()
        end
    end

    if key == 'x' then
        local mapn = diamondSquare.mapn + 1
        if mapn <= 10 then
            diamondSquare = DiamonAndSquare.new(mapn, rng, pipeline)
            diamondSquare:eval()
            diamondSquare:send2render()
            lines_buf_push_mapn()
        end
    end
end

-- Сброс физики - удаление пространства, всех тел и фигур
local function physics_reset()
    wrp.space_free(space)
    space = wrp.space_new(space_damping)
    wrp.space_set(space)
    print(colorize("%{blue}physics reseted"))
end

-- Сброс состояния рендера. 
-- Посылаются сообщения всем используемым объектам об очистке текущего 
-- состояния в начальное.
local function render_reset_state()
    pipeline:openPushAndClose('base_shape', 'clear')
end

-- Создать сегменты ограничивающие карту
local function initBorders()
    local lf = love.filesystem
    local borders_data: {Borders}

    -- Удалить существующие сегменты если они созданы.
    if #segments ~= 0 then
        for _, v in ipairs(segments) do
            --wrp.free_static_segment(v)
        end
    end

    local ok, msg = pcall(function()
        local path = SCENE_PREFIX .. "/borders_data.lua" 
        borders_data = lf.load(path)() as {Borders}
    end) as (boolean, string)
    if not ok then
        error('Could not load borders data: ' .. msg)
    else
        print(colorize("%{blue}borders loaded"))
    end

    if borders_data then
        for _, b in ipairs(borders_data) do
            print('border', inspect(b))
            --local segment = wrp.new_static_segment(b.x1, b.y1, b.x2, b.y2)
            --table.insert(segments, segment)
            -- XXX сделать добавление сегментов в таблицу
            wrp.static_segment_new(b.x1, b.y1, b.x2, b.y2)
        end
    else
        print(colorize("${red}" .. "no borders data"))
    end
end

local function spawnPlayer()
    local px, py = screenW / 3, screenH / 2
    playerTank = spawnTank(px, py)
    camera:setPlayer(playerTank)

    -- near friend for debugger
    spawnTank(px + 400, py)
end

local function nextTankAsPlayer()
    print('nextTankAsPlayer')
    local index = -1
    for k, v in ipairs(tanks) do
        if v == playerTank then
            index = k + 1
            break
        end
    end
    if tanks[index] then
        playerTank = tanks[index]
    else
        playerTank = tanks[1]
    end
    camera:setPlayer(playerTank)
end

local function prevTankAsPlayer()
    print('prevTankAsPlayer')
    local index = -1
    for k, v in ipairs(tanks) do
        if v == playerTank then
            index = k - 1
            break
        end
    end
    if tanks[index] then
        playerTank = tanks[index]
    else
        playerTank = tanks[#tanks]
    end
    camera:setPlayer(playerTank)
end

local function changePlayerTank(key: string)
    if love.keyboard.isDown('lshift') then
        if key == 'left' then
            prevTankAsPlayer()
        elseif key == 'right' then
            nextTankAsPlayer()
        end
    end
end

local function changeWindowMode()
    --if love.window.getFullscreen() then
    love.window.setFullscreen(not love.window.getFullscreen())
end

local function keypressed(key: string)
    -- {{{
    print('keypressed', key)

    if key == "escape" then
        is_stop = true
        debug_print('input', colorize('%{blue}escape pressed'))
    end

    -- Пауза для физики
    if key == "p" then
        physics_pause = not physics_pause
    end

    if key == 'f1' then
        is_draw_hotkeys_docs = not is_draw_hotkeys_docs
        if is_draw_hotkeys_docs then
            is_draw_gamepad_docs = false
        end
    elseif key == 'f11' then
        changeWindowMode()
    end

    if physics_pause then
        -- Полностью перезагрузить уровень.
        if key == 'q' then

            physics_reset()
            render_reset_state()
            initBorders()
            spawnTanks()
            spawnPlayer()

        -- Перезагрузить сегменты из файла.
        elseif key == '1' then
            -- FIXME падает если вызвать несколько раз
            initBorders()
        end
    end

    processLandscapeKeys(key)
    changePlayerTank(key)

    -- }}}
end

--[[
local function bindKonsoleCameraZoomKeys()
    -- {{{
    local ids = {
        KeyConfig.bind(
            "isdown",
            { mod = { "lshift" },
                key = "z" },
            function(sc: Shortcut): boolean, Shortcut
                if mode ~= "normal" then
                    return false, sc
                end

                --if konsoleCam.scale < camZoomHigher then
                    --konsoleCam:zoom(1. + zoomSpeed)
                --end

                return false, sc
            end,
            "zoom camera in",
            "zoomin"
        ),
        KeyConfig.bind(
            "isdown",
            { key = "x" },
            function(sc: Shortcut): boolean, Shortcut
                if mode ~= "normal" then
                    return false, sc
                end

                --if konsoleCam.scale > camZoomLower then
                    --konsoleCam:zoom(1.0 - zoomSpeed)
                --end

                return false, sc
            end,
            "zoom camera out",
            "zoomout"
        ),
    }
    cameraKeyConfigIds = {}
    for _, v in ipairs(ids) do
        table.insert(cameraKeyConfigIds, v)
    end
    print('bindKonsoleCameraZoomKeys')
    -- }}}
end
--]]

--[[
local function initRenderCode()
    -- {{{

    -- рисовать ортогональные оси координат в левом верхнем углу экрана
    -- {{{
    pipeline:pushCode("main_axises", [[
    local gr = love.graphics
    --local col = {0.3, 0.5, 1, 1}
    --local col = {0, 0, 0, 1}
    local col = {27. / 255, 94. / 255., 194. / 255}
    local rad = 100
    local size = 1000

    while true do
        gr.setColor(col)
        --gr.setColor {0, 0, 0, 1}
        gr.setLineWidth(1)
        gr.circle("line", 0, 0, rad)
        gr.line(0, size, 0, -size)
        gr.line(-size, 0, size, 0)

        coroutine.yield()
    end
    ]])
    -- }}}

    -- Буфер для вывода отладочной информации в левом верхнем углу экрана.
    pipeline:pushCodeFromFile('lines_buf', 'lines_buf.lua')
    -- Буфер для вывода отладочной информации при наведении на физическое тело.
    pipeline:pushCodeFromFile('object_lines_buf', 'lines_buf.lua')
    docsystem.init_render_stage1(pipeline)

    -- Рисование прозрачного прямоугольника над определенным телом.
    -- {{{
    pipeline:pushCode('selected_object', [[
    -- жесткие значения ширины и высоты, как проверить что они соответствуют
    -- действительным?
    local width, height = 256, 256
    local selection_color = {0, 0.5, 1, 0.3}
    local border_color = {0, 0, 0, 1}
    local linew = 5

    local x, y, angle: number
    local gr = love.graphics
    while true do
        x = graphic_command_channel:demand() as number
        y = graphic_command_channel:demand() as number
        angle = graphic_command_channel:demand() as number

        gr.push()
        gr.translate(x, y)
        gr.rotate(angle)
        gr.translate(-width / 2, -height / 2)

        gr.setColor(selection_color)
        gr.rectangle('fill', 0, 0, width, height)

        gr.setColor(border_color)
        gr.setLineWidth(linew)
        gr.rectangle('line', 0, 0, width, height)

        gr.pop()

        coroutine.yield()
    end
    ]])
    -- }}}

    -- Очистка экрана
    -- {{{
    pipeline:pushCode('clear', [[
    while true do
        love.graphics.clear{0.5, 0.5, 0.5}
        coroutine.yield()
    end
    ]])
    -- }}}

    -- Установить трансформацию
    -- {{{
    pipeline:pushCode('set_transform', [[
    local gr = love.graphics
    local yield = coroutine.yield
    while true do
        gr.applyTransform(graphic_command_channel:demand())
        yield()
    end
    ]])
    -- }}}

    -- Сброс трансформации
    -- {{{
    pipeline:pushCode('origin_transform', [[
    local gr = love.graphics
    local yield = coroutine.yield
    while true do
        gr.origin()
        yield()
    end
    ]])
    -- }}}

    pipeline:pushCodeFromFile("debug_vertices", "debug_vertices.lua")

    -- Рисование физических тел.
    pipeline:pushCodeFromFile("base_shape", 'poly_shape.lua')
    -- Рисование физических тел.
    --pipeline:pushCodeFromFile("turret_shape", 'poly_shape.lua')

    -- Рисование линий физических сегментов используемых для ограничения 
    -- игрового поля.
    pipeline:pushCodeFromFile('border_segments', 'border_segments.lua')

    -- }}}
end

-- Инициализация параметрами объектов-корутин на стороне главного потока.
local function initPipelineObjects()
    pipeline:open('base_shape')
    -- XXX Временное решение. Какие размеры башни?
    local turret_width, turret_height = tank_width, tank_height
    pipeline:push(
        base_tex_fname, 
        turret_text_fname, 
        tank_width, 
        tank_height,
        turret_width,
        turret_height
    )
    --[[
    Пиксели для вырезки
    82*108
    86(?), 74
    --]]
    pipeline:close()

    --pipeline:open('turret_shape')
    --pipeline:push(turret_text_fname, tank_width, tank_height)
    --[[
    Пиксели для вырезки
    52*159
    102, 1
    --]]
    --pipeline:close()

    local dejavu_mono = "DejaVuSansMono.ttf"
    pipeline:openPushAndClose('lines_buf', dejavu_mono, 24)
    pipeline:openPushAndClose('object_lines_buf', dejavu_mono, 30)

    docsystem.init_render_stage2()

    pipeline:openAndClose("debug_vertices")

    pipeline:sync()

    --[[
    pipeline:openPushAndClose(
        'lines_buf',                -- coroutine object name
        "add",                      -- object command
        'hi',                       -- message id
        "привет из недр движка",    -- message(payload)
        "flush"                     -- render buffer and break waiting cycle
    )
    --]]

end

local function add_gamepad_docs()
    docsystem.add_keyboard_doc("escape", "exit")
    docsystem.add_keyboard_doc("r", "Rebuild map")
    docsystem.add_keyboard_doc('z', 'Decrease map size')
    docsystem.add_keyboard_doc('x', 'Increase map size')
    docsystem.add_keyboard_doc('shift+left', 'Previous tank as player')
    docsystem.add_keyboard_doc('shift+right', 'Next tank as player')
    docsystem.add_keyboard_doc('p', 'Pause for physics engine. "P" - mode')
    docsystem.add_keyboard_doc('f1', 'Show or hide this text')
    docsystem.add_keyboard_doc('q', "Fully reload map with objects.")
    docsystem.add_keyboard_doc('1', 'Reload static physics segments.')
    docsystem.finish_keyboard_docs()
end

local function add_keyboard_docs()
    docsystem.add_gamepad_doc("start", "show this help")
    docsystem.add_gamepad_doc("left shift", "reset camera")
    docsystem.add_gamepad_doc('right shift', 'move camera to player')
    docsystem.add_gamepad_doc('X', 'rotate left')
    docsystem.add_gamepad_doc('B', 'rotate right')
    docsystem.add_gamepad_doc('Y', 'move forward')
    docsystem.add_gamepad_doc('A', 'move backward')
    docsystem.finish_gamepad_docs()
end

local function init()
    -- {{{
    print('init started')
    metrics.init()
    space = wrp.space_new(space_damping)
    wrp.space_set(space)

    screenW, screenH = pipeline:getDimensions()
    print('screenW, screenH', screenW, screenH)

    -- Требует инициализации после создания объекта pipeline, но до функций
    -- init*
    camera = PCamera.new(pipeline, screenW, screenH)

    -- Начало геймпада
    initJoy()
    -- Загрузка удаленного кода для рисования
    initRenderCode()
    -- Дополнительная инициализация объектов рисовки.
    initPipelineObjects()

    add_keyboard_docs()
    add_gamepad_docs()

    --loadLocales()

    --logo = Logo.new()

    --bindCameraZoomKeys()
    --bindKonsoleCameraZoomKeys()
    --bindCameraControl()

    bindFullscreenSwitcher()

    --bindEscape()
    --bindKonsole()
    --bindTerrainControlKeys()
    --bindDeveloperKeys()

    --arena = Arena.new("arena.lua")
    --terrain()
    local corners = getTerrainCorners()
    if corners then
        for _, c in ipairs(corners) do
            spawnHangar(c)
        end
    end

    -- }}}
    last_render = love.timer.getTime()
    print('init finished')
end

local function quit()
    -- {{{
    metrics.quit()
    tanks = {}
    --writeParticles(particlesfname)
    -- }}}
end

local stat_push_counter = 0

local function inc_push_counter(): integer
    local prev_value = stat_push_counter
    stat_push_counter = stat_push_counter + 1
    return prev_value
end

local function push_tank_body_stat(object: Wrapper.Tank)
    local msg = ""
    local mass, inertia, cog_x, cog_y, pos_x, pos_y, v_x, v_y, 
        force_x, force_y, angle, w, torque = object:get_body_stat()

    msg = sformat('mass, inertia: %.3f, %.3f', mass, inertia)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('cog (%.3f, %.3f)', cog_x, cog_y)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('position (%.3f, %.3f)', pos_x, pos_y)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('velocity (%.3f, %.3f)', v_x, v_y)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('force (%.3f, %.3f)', force_x, force_y)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('angle, ang. vel.: %.3f, %.3f)', angle, w)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('torque: %.3f', torque)
    pipeline:push('add', inc_push_counter(), msg)
end

local function push_tank_turret_stat(object: Wrapper.Tank)
    local msg = ""
    local mass, inertia, cog_x, cog_y, pos_x, pos_y, v_x, v_y, 
        force_x, force_y, angle, w, torque = object:get_turret_stat()

    msg = sformat('mass, inertia: %.3f, %.3f', mass, inertia)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('cog (%.3f, %.3f)', cog_x, cog_y)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('position (%.3f, %.3f)', pos_x, pos_y)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('velocity (%.3f, %.3f)', v_x, v_y)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('force (%.3f, %.3f)', force_x, force_y)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('angle, ang. vel.: %.3f, %.3f)', angle, w)
    pipeline:push('add', inc_push_counter(), msg)

    msg = sformat('torque: %.3f', torque)
    pipeline:push('add', inc_push_counter(), msg)
end

local function mousemoved(x: number, y: number, dx: number, dy: number)
    metrics.mousemoved(x, y, dx, dy)

    local absx, absy = -camera.x, -camera.y

    --print('absx, absy', absx, absy)
    local counter = 0
    wrp.get_body_under_point(x + absx, y + absy, 
        function(
            object: Wrapper.Tank,
            shape_x: number,
            shape_y: number,
            dist: number,
            gradx: number,
            grady: number
        )

        if not object then
            error("get_body_under_point: object in nil")
        end

        print("under cursor")

        local msg = ""
        counter = counter + 1
        pipeline:open('object_lines_buf')
        --pipeline:push('pos', absx, absy)
        pipeline:push('pos', x + absx, y + absy)
        pipeline:push('add', inc_push_counter(), 'object ' .. tostring(object))

        msg = sformat('point (%.3f, %.3f)', shape_x, shape_y)
        pipeline:push('add', inc_push_counter(), msg)

        pipeline:push('add', inc_push_counter(), 'distance ' .. dist)
        pipeline:push('add', inc_push_counter(), sformat('gradient (%.3f, %.3f)', gradx, grady))

        pipeline:push('add', inc_push_counter(), "----------")

        --wrp.shape_print_filter(shape)
        push_tank_body_stat(object)
        pipeline:push('add', inc_push_counter(), "----------")
        push_tank_turret_stat(object)

        pipeline:push('enough')
        pipeline:close()
    end)

    if counter == 0 then
        pipeline:openPushAndClose('object_lines_buf', 'clear')
    end
    stat_push_counter = 0

    --if mode == 'editor' then
        --arena:mousemoved(x, y, dx, dy)
    --end
end

local function wheelmoved(x: number, y: number)
    metrics.wheelmoved(x, y)
end

--[[
Сделать передвижение камеры по зажатию средней клавиши мыши.
--]]
local function mousepressed(x: number, y: number, btn: integer)
    -- {{{
    metrics.mousepressed(x, y, btn)
    -- }}}
end

local function updateJoyState()
    joyState:update()
    if joyState.state and joyState.state ~= "" then
        debug_print('joy', joyState.state)
    end
end

local function joystickpressed(_: Joystick, button: integer)
    local left_shift = 5
    local right_shift = 6
    local start = 8

    if button == left_shift then
        print("setToOrigin()")
        camera:setToOrigin()
    end
    if button == right_shift then
        print("moveToPlayer()")
        camera:moveToPlayer()
    end
    if button == start then
        -- Вывести справку по управлению
        is_draw_gamepad_docs = not is_draw_gamepad_docs
        is_draw_hotkeys_docs = false
    end
end

local function process_events()
    local events = event_channel:pop() as {any}
    if events then
        for _, e in ipairs(events) do
            local evtype: string = (e as {string})[1]
            if evtype == "mousemoved" then

                local x, y = (e as {number})[2], (e as {number})[3]
                local dx, dy = (e as {number})[4], (e as {number})[5]
                mousemoved(x, y, dx, dy)

            elseif evtype == 'wheelmoved' then

                local x, y = (e as {number})[2], (e as {number})[3]
                wheelmoved(x, y)

            elseif evtype == "keypressed" then
                local key = (e as {string})[2]
                local scancode = (e as {string})[3]

                local msg = '%{green}keypressed '
                debug_print('input', colorize(msg .. key .. ' ' .. scancode))

                if love.keyboard.isDown('lshift') then
                    dprint.keypressed(scancode)
                end

                -- Использовать scancode или key?
                keypressed(scancode)

                --msg = '%{yellow}keypressed '
                --print(colorize(msg .. key .. ' ' .. scancode))

            elseif evtype == "mousepressed" then
                local x, y = (e as {number})[2], (e as {number})[3]
                local btn = (e as {integer})[4]
                mousepressed(x, y, btn)

            elseif evtype == "joystickpressed" then
                local joystick = (e as {number})[2] as Joystick
                local button = (e as {number})[3] as integer
                joystickpressed(joystick, button)
            end
        end
    end
end

--[[
Задача: написать модуль, встроенный в бинарный файл love, для замены
pipeline.tl
--]]
--local pp = require "mtpipeline"
--pp.init()
--pp.free()

local function applyInput(j: Joystick)
    -- Нужно and или or?
    if not j and not playerTank then
        return
    end

    local left, right, up, down = 3, 2, 4, 1

    --[[
    Как узнать направление движения и направление приложения силы?
    --]]

    -- FIXME Если прикладывать слишком большой импульс, то объект пролетает
    -- за заграждение в виде EdgeShape
    if j:isDown(right) then
        playerTank:right()
    elseif j:isDown(left) then
        playerTank:left()
    elseif j:isDown(up) then
        playerTank:forward()
    elseif j:isDown(down) then
        playerTank:backward()
    end

    local hut_num = 1
    --local msg = j:getHat(hut_num)
    --love.filesystem.append("hat", msg, #(msg as string))

    local hut = j:getHat(hut_num)
    if hut == "l" then
        playerTank:rotate_turret("left")
    elseif hut == "r" then
        playerTank:rotate_turret("right")
    end

    if joyState.state then
        --love.filesystem.append("joystate", joyState.state, #joyState.state)
        --print(joyState.state)
    end
end

local stateCoro: thread = coroutine.create(function(dt: number)

    initBorders()
    spawnTanks()
    spawnPlayer()

    diamondSquare:eval()
    diamondSquare:send2render()
    --lines_buf_push_mapn()

    while true do
        if state == 'map' then
            process_events()
            renderScene()
            updateTanks()

            ------------ UPDATE HERE PLEASE ------------ 
            --arena:update()

            camera:checkInput(joy)
            camera:update(dt)

            -- шаг физики
            if not physics_pause then
                wrp.space_step(dt);
            end

            --[[
            Почему тела не расталкиваются?
            Мигания рендера
            --]]
    
            applyInput(joy)
            updateJoyState()

            dt = yield() as number
        elseif state == 'garage' then
            --coroutine.yield()
        end
        --print('state', state)
    end
end)

local function mainloop()
    local last_time = love.timer.getTime()
    while not is_stop do
        local now_time = love.timer.getTime()
        local dt = now_time - last_time
        last_time = now_time

        local ok, errmsg = resume(stateCoro, dt) as (boolean, string)
        if not ok then
            error('stateCoro: ' .. errmsg)
        end

        local timeout = 0.0001
        love.timer.sleep(timeout)
    end
end

--[[
-- {{{ BulletPool prototype
local record BulletPool
    new: function(BulletPool, num: integer): BulletPool
    spaw: function(x: number, y: number): Bullet
end

function BulletPool.new(num: integer): BulletPool
    local BulletPool_mt: metatable<BulletPool> = {
        __index = BulletPool,
    }
    local self = setmetatable({} as BulletPool, BulletPool_mt)
    return self
end
-- }}}
--]]

init()
mainloop()

if is_stop then
    quit()
    print('space', space)
    wrp.space_free(space)
    main_channel:push('quit')
    debug_print('thread', 'Thread resources are freed')
end

debug_print('thread', colorize('%{yellow}<<<<<%{reset} t80 finished'))
